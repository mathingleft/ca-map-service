<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>California Demand — Hex Sampling within State Boundary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body,
    #container {
      margin: 0;
      height: 100%;
      width: 100%;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: rgba(255, 255, 255, .96);
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, .15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #ui .row {
      display: flex;
      align-items: center;
      gap: .5rem;
    }

    #ui label {
      font-size: .9rem;
      color: #333;
    }

    #ui input[type=range] {
      width: 180px;
    }
  </style>

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- deck.gl -->
  <script src="https://unpkg.com/deck.gl@8.9.34/dist.min.js"></script>

  <!-- turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="./rbush.min.js"></script>

</head>

<body>
  <div id="container"></div>
  <div id="ui">
    <div class="row"><strong>California Map Service</strong></div>
    <div class="row" style="margin-top:.25rem">
      <label>Hex size (pixels): <span id="hex_px_label">26</span></label>
      <input id="hex_px" type="range" min="12" max="60" value="26" step="2" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <label>Opacity (alpha): <span id="hex_opacity_label">125</span></label>
      <input id="hex_opacity" type="range" min="0" max="255" value="125" step="5" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <input id="allow_zero" type="checkbox" checked />
      <label for="allow_zero">Allow (radius < starting radius) when (ZIP's doctors ≥ 5)</label>
    </div>
    <div class="row" style="font-size:0.9rem;color:#555;margin-bottom:.3rem">
      Approximated by affecting demand in radius of 0.1 miles.
    </div>
    <div class="row" style="margin-top:.25rem">
      <label for="start_radius">Starting radius (mi):</label>
      <input id="start_radius" type="number" min="0" step="1" value="5" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <label for="inc_radius">Radius increment (mi):</label>
      <input id="inc_radius" type="number" min="1" step="1" value="5" />
    </div>
  </div>

  <script>
    // CONFIG
    const DATA_URL = './zips.json';
    const MAP_STYLE = `https://api.maptiler.com/maps/streets/style.json?key=NYtv1R1Zg4AkgQWZVE5K`;
    const ZCTA_URL = './zcta_ca_centroid.geojson';
    const START_VIEW = { latitude: 37.25, longitude: -119.75, zoom: 6, bearing: 0, pitch: 0 };
    const MI_TO_KM = 1.609344;
    const MAX_HEX_DISTANCE_MI = 150;
    const MAX_HEX_DISTANCE_KM = MAX_HEX_DISTANCE_MI * MI_TO_KM;

    const EARTH_RADIUS_KM = 6371.0088;
    //const US_STATES_GEOJSON = 'https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json';
    const CA_BOUNDARY_URL = './ca_boundary.json';
    const SHOW_ZERO_CELLS = false;

    const hexPxSlider = document.getElementById('hex_px');
    const hexPxLabel = document.getElementById('hex_px_label');
    let HEX_PIXEL_SIZE = +hexPxSlider.value;

    const hexOpacitySlider = document.getElementById('hex_opacity');
    const hexOpacityLabel = document.getElementById('hex_opacity_label');
    let HEX_OPACITY = +hexOpacitySlider.value;

    const allowZeroEl = document.getElementById('allow_zero');
    const startRadiusEl = document.getElementById('start_radius');
    const incRadiusEl = document.getElementById('inc_radius');

    // UTILS
    function metersPerPixel(lat, zoom) {
      const mpp256 = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
      return mpp256 / 2;
    }

    function hexPolygon([lon, lat], Rm) {
      const latRad = lat * Math.PI / 180;
      const mPerDegLat = 111132.92 - 559.82 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
      const mPerDegLon = 111412.84 * Math.cos(latRad) - 93.5 * Math.cos(3 * latRad);
      const dLat = Rm / mPerDegLat, dLon = Rm / mPerDegLon;
      const ang = [30, 90, 150, 210, 270, 330].map(a => a * Math.PI / 180);
      return ang.map(a => [lon + dLon * Math.cos(a), lat + dLat * Math.sin(a)]);
    }

    function makeHexCenters(vs, hexPixelSize = HEX_PIXEL_SIZE) {
      const { longitude, latitude, zoom, width, height } = vs;
      const mpp = metersPerPixel(latitude, zoom);
      const Rm = Math.max(200, (hexPixelSize * mpp) / 2);

      const vp = new deck.WebMercatorViewport(vs);
      const nw = vp.unproject([0, 0]);
      const se = vp.unproject([width, height]);
      const minLon = Math.min(nw[0], se[0]);
      const maxLon = Math.max(nw[0], se[0]);
      const minLat = Math.min(se[1], nw[1]);
      const maxLat = Math.max(se[1], nw[1]);

      const latRad = latitude * Math.PI / 180;
      const mPerDegLat = 111132.92 - 559.82 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
      const mPerDegLon = 111412.84 * Math.cos(latRad) - 93.5 * Math.cos(3 * latRad);
      const stepLon = (2 * Rm) / mPerDegLon;
      const stepLat = (Math.sqrt(3) * Rm) / mPerDegLat;

      const centers = [];
      let row = 0;
      for (let lat = minLat - stepLat; lat <= maxLat + stepLat; lat += stepLat, row++) {
        const lonOffset = (row % 2 === 0) ? 0 : stepLon / 2;
        for (let lon = minLon - stepLon; lon <= maxLon + stepLon; lon += stepLon) {
          centers.push([lon + lonOffset, lat]);
        }
      }
      return { centers, hexRadiusMeters: Rm };
    }

    function haversineKm(lat1, lon1, lat2, lon2) {
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
      return 2 * EARTH_RADIUS_KM * Math.asin(Math.sqrt(a));
    }

    function bandsForMiles(latDeg, miles) {
      if (miles <= 0) return { latBand: 0, lonBand: 0 };
      const latBand = miles / 69.0; // ~1 deg lat ≈ 69 miles
      const lonBand = miles / (69.172 * Math.max(0.01, Math.cos(latDeg * Math.PI / 180)));
      return { latBand, lonBand };
    }


    function withinMilesBB(lat1, lon1, lat2, lon2, miles) {
      const { latBand, lonBand } = bandsForMiles(lat1, miles);
      return (lat2 >= lat1 - latBand && lat2 <= lat1 + latBand &&
        lon2 >= lon1 - lonBand && lon2 <= lon1 + lonBand);
    }

    // GLOBALS
    let POINTS = [];
    let SUM_DOCTORS = null;
    let CA_FEATURE = null;
    let ZCTA_FEATURES = null;
    let ZCTA_INDEX = null;
    let overlay = null;
    let map = null;

    // LOADERS
    async function loadData() {
      try {
        const r = await fetch(DATA_URL, { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        return await r.json();
      } catch (e) {
        if (!USE_INLINE_FALLBACK) throw e;
        return JSON.parse(document.getElementById('zipdata').textContent.trim());
      }
    }

    function buildZctaIndex() {
      ZCTA_INDEX = rbush(9);
      const items = [];
      const feats = (ZCTA_FEATURES && ZCTA_FEATURES.features) || [];
      for (let i = 0; i < feats.length; i++) {
        const b = turf.bbox(feats[i]); // [minX, minY, maxX, maxY] in [lon, lat]
        items.push({ minX: b[0], minY: b[1], maxX: b[2], maxY: b[3], i });
      }
      ZCTA_INDEX.load(items);
    }

    /** Returns containing ZCTA feature for (lon,lat), or null */
    function findZctaForPoint(lon, lat) {
      if (!ZCTA_INDEX) return null;
      const cands = ZCTA_INDEX.search({ minX: lon, minY: lat, maxX: lon, maxY: lat });
      for (const it of cands) {
        const f = ZCTA_FEATURES.features[it.i];
        if (turf.booleanPointInPolygon([lon, lat], f)) return f;
      }
      return null;
    }

    async function ensureRbush() {
      // If already present (e.g., from local rbush.min.js), done.
      if (window.rbush) return;

      // Try dynamic ESM imports that return the class as .default
      const candidates = [
        'https://cdn.jsdelivr.net/npm/rbush@3.0.1/+esm',
        'https://unpkg.com/rbush@3.0.1/+esm'
      ];

      for (const url of candidates) {
        try {
          const mod = await import(url);
          // expose a global-compatible factory so the rest of your code can call rbush(...)
          window.rbush = function rbushFactory(maxEntries) {
            // rbush ESM default export is the class; `new` creates the tree
            return new mod.default(maxEntries);
          };
          return;
        } catch (e) {
          console.warn('Failed to import rbush from', url, e);
        }
      }

      // Last resort: try loading a local fallback if you saved rbush.min.js next to index.html
      try {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = './rbush.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
        if (window.rbush) return;
      } catch (e) {
        console.warn('Local rbush.min.js failed to load', e);
      }

      throw new Error('rbush could not be loaded from any source');
    }

    async function loadBoundary() {
      // Try local high-res file first
      try {
        const r = await fetch(CA_BOUNDARY_URL, { cache: 'no-cache' });
        if (r.ok) {
          const gj = await r.json();

          // --- Normalize to a single Feature (Polygon/MultiPolygon)
          let feat;
          if (gj.type === 'Feature') {
            feat = gj;
          } else if (gj.type === 'FeatureCollection') {
            // If your json has multiple features, pick the one that is CA or a Polygon
            feat = gj.features.find(f =>
              f?.geometry?.type === 'Polygon' || f?.geometry?.type === 'MultiPolygon'
            ) || gj.features[0];
          } else if (gj.type === 'Polygon' || gj.type === 'MultiPolygon') {
            feat = { type: 'Feature', properties: { name: 'California' }, geometry: gj };
          }

          if (!feat || !feat.geometry || !feat.geometry.coordinates) {
            console.error('CA boundary file did not contain a Polygon/MultiPolygon Feature:', gj);
            throw new Error('Invalid CA boundary GeoJSON');
          }

          console.log('CA boundary loaded. type:', feat.geometry.type);
          return feat;
        }
      } catch (e) {
        console.warn('CA polygon fetch failed, falling back to inline rectangle.', e);
      }

      // Fallback: inline rectangle you already had
      const fc = JSON.parse(document.getElementById('cali-boundary').textContent.trim());
      return fc.features[0];
    }

    // RENDER
    function renderAdjustedDemand(viewState) {
      if (!CA_FEATURE) return;

      // Read UI
      const allowZero = !!allowZeroEl?.checked;
      const startMiles = Math.max(0, parseInt(startRadiusEl?.value || '1', 10));
      const incMiles = Math.max(1, parseInt(incRadiusEl?.value || '1', 10));

      // Build hex centers
      const { centers, hexRadiusMeters } = makeHexCenters(viewState);
      const features = [];

      // Pre-extract zip arrays for faster tight loops
      const ZN = POINTS.length;
      const zLat = new Float64Array(ZN);
      const zLon = new Float64Array(ZN);
      const zDem = new Float64Array(ZN);
      const zMin = new Int32Array(ZN);
      //const zDoc = new Float64Array(ZN);
      for (let i = 0; i < ZN; i++) {
        const p = POINTS[i];
        zLat[i] = +p.lat;
        zLon[i] = +p.lon;
        zDem[i] = +p.demand || 0;
        zMin[i] = Math.max(0, Math.round(+p.min_radius || 0));
        //zDoc[i] = +p.doctors || 0;
      }

      centers.forEach(([hxLon, hxLat]) => {
        if (!turf.booleanPointInPolygon([hxLon, hxLat], CA_FEATURE)) return;

        // Bounding box for 150 mi around this hex center (cheap prefilter)
        const { latBand: hexLatBand, lonBand: hexLonBand } = bandsForMiles(hxLat, MAX_HEX_DISTANCE_MI);

        let adjusted = 0;

        // Loop candidate ZIPs within 150 miles of hex center
        for (let i = 0; i < ZN; i++) {
          const lat = zLat[i], lon = zLon[i];

          // BB prune
          if (!(lat >= hxLat - hexLatBand && lat <= hxLat + hexLatBand &&
            lon >= hxLon - hexLonBand && lon <= hxLon + hexLonBand)) continue;

          // Exact 150-mi check
          if (haversineKm(hxLat, hxLon, lat, lon) > MAX_HEX_DISTANCE_KM) continue;

          // Decide working radius for this ZIP
          let rMiles;
          if (allowZero && zMin[i] === 0) {
            rMiles = 0;
          } else {
            rMiles = startMiles;
            while (rMiles < zMin[i]) rMiles += incMiles;
          }

          // If hex–zip distance exceeds working radius, skip this ZIP
          if (rMiles > 0) {
            if (!withinMilesBB(hxLat, hxLon, lat, lon, rMiles) ||
              haversineKm(hxLat, hxLon, lat, lon) > rMiles * MI_TO_KM) continue;
          } else {
            // radius == 0 → require hex center and the data point to be in the SAME ZCTA polygon
            const zcta = findZctaForPoint(hxLon, hxLat); // [lon, lat]
            if (!zcta) continue;

            // Is the source point inside this very polygon?
            if (!turf.booleanPointInPolygon([lon, lat], zcta)) continue;
            /*
            // (Optional) require ≥5 doctors in that ZCTA
            const hexZip = String(
              zcta.properties.zip ||
              zcta.properties.GEOID10 ||
              zcta.properties.ZCTA5CE10 ||
              ''
            ).padStart(5, '0');

            const doctorsTotal = Number(
              (zcta.properties && zcta.properties.doctors_total) ??
              (DOCS_BY_ZIP && DOCS_BY_ZIP[hexZip]) ?? 0
            );
            if (allowZero && doctorsTotal < 5) continue;
            */
          }

          const rIdx = Math.max(0, Math.min(150, rMiles | 0));   // clamp & ensure integer
          const sumDocs = SUM_DOCTORS[i][rIdx] || 0;

          if (sumDocs > 0) adjusted += (zDem[i] / sumDocs);
          // else: no contribution (avoid div-by-zero)
        }

        features.push({ center: [hxLon, hxLat], adjusted });
      });

      const used = (features.filter(f => f.adjusted > 0));

      // If nothing to draw, keep border only
      if (used.length === 0) {
        overlay.setProps({
          layers: [new deck.GeoJsonLayer({
            id: 'cali-border',
            data: CA_FEATURE,
            stroked: true,
            filled: false,
            getLineColor: [0, 0, 0, 200],
            lineWidthMinPixels: 2
          })],
          getTooltip: null
        });
        return;
      }

      // Color scaling by adjusted demand
      const maxVal = Math.max(1, ...used.map(f => f.adjusted));
      const colorFor = v => {
        const t = Math.min(1, v / maxVal);
        return [255, Math.floor(255 * (1 - t)), Math.floor(60 + 60 * (1 - t)), HEX_OPACITY];
      };

      const polygons = used.map(f => ({
        polygon: hexPolygon(f.center, hexRadiusMeters),
        adjusted: f.adjusted,
        color: colorFor(f.adjusted)
      }));

      const hexLayer = new deck.PolygonLayer({
        id: 'adjusted-hexes',
        data: polygons,
        getPolygon: d => d.polygon,
        getFillColor: d => d.color,
        stroked: false,
        filled: true,
        pickable: true
      });

      const borderLayer = new deck.GeoJsonLayer({
        id: 'cali-border',
        data: CA_FEATURE,
        stroked: true,
        filled: false,
        getLineColor: [0, 0, 0, 200],
        lineWidthMinPixels: 2
      });

      const zctaOutlineLayer = new deck.GeoJsonLayer({
        id: 'zcta-outline',
        data: ZCTA_FEATURES || { type: 'FeatureCollection', features: [] },
        stroked: true,
        filled: false,
        getLineColor: [85, 85, 85, 180],
        lineWidthMinPixels: 1
      });


      overlay.setProps({
        layers: [borderLayer, zctaOutlineLayer, hexLayer],
        getTooltip: ({ object }) =>
          object ? `Panel demand per yearly quarter per doctor: ${object.adjusted.toFixed(4)}` : null
      });
    }

    // STARTUP
    Promise.all([
      ensureRbush(),
      loadData(),
      loadBoundary(),
      fetch(ZCTA_URL).then(r => r.json()),
      //fetch(DOCS_BY_ZIP_URL).then(r => r.ok ? r.json() : ({})) // ok if missing
    ]).then(([_, rows, ca, zcta]) => {
      POINTS = rows.map(d => ({
        lon: +d.longitude,
        lat: +d.latitude,
        demand: Number(d.demand) || 0,
        min_radius: Math.max(0, Math.round(Number(d.min_radius) || 0)),
        zip: ('' + (d.zip ?? d.ZIP ?? '')).padStart(5, '0') // <-- keep ZIP for r=0 check
      })).filter(p => Number.isFinite(p.lon) && Number.isFinite(p.lat));
      console.log('Loaded ZIP points:', POINTS.length);

      CA_FEATURE = ca;
      console.log('Loaded CA feature from source:', CA_FEATURE.properties?.name || CA_FEATURE.properties?.NAME);

      // If your DATA_URL is doctors_cumu.json, this exists; if it's zips.json, ensure it has sum_doctors
      SUM_DOCTORS = rows.map(d => d.sum_doctors);

      ZCTA_FEATURES = zcta;
      //DOCS_BY_ZIP = docsByZip || {};

      buildZctaIndex(); // <-- build spatial index once

      map = new maplibregl.Map({
        container: 'container',
        style: MAP_STYLE,
        center: [START_VIEW.longitude, START_VIEW.latitude],
        zoom: START_VIEW.zoom
      });

      overlay = new deck.MapboxOverlay({ interleaved: true, layers: [] });
      map.addControl(overlay);

      map.on('move', () => {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      });

      // First render
      renderAdjustedDemand({
        longitude: map.getCenter().lng,
        latitude: map.getCenter().lat,
        zoom: map.getZoom(),
        pitch: map.getPitch(),
        bearing: map.getBearing(),
        width: map.getContainer().clientWidth,
        height: map.getContainer().clientHeight
      });
    });


    // SLIDERS
    hexPxSlider.addEventListener('input', () => {
      HEX_PIXEL_SIZE = +hexPxSlider.value;
      hexPxLabel.textContent = HEX_PIXEL_SIZE;
      if (map) {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      }
    });

    hexOpacitySlider.addEventListener('input', () => {
      HEX_OPACITY = +hexOpacitySlider.value;
      hexOpacityLabel.textContent = HEX_OPACITY;
      if (map) {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      }
    });

    function rerenderNow() {
      if (!map) return;
      const vs = {
        longitude: map.getCenter().lng,
        latitude: map.getCenter().lat,
        zoom: map.getZoom(),
        pitch: map.getPitch(),
        bearing: map.getBearing(),
        width: map.getContainer().clientWidth,
        height: map.getContainer().clientHeight
      };
      renderAdjustedDemand(vs);
    }

    allowZeroEl.addEventListener('change', rerenderNow);
    startRadiusEl.addEventListener('input', rerenderNow);
    incRadiusEl.addEventListener('input', rerenderNow);
  </script>
</body>

</html>