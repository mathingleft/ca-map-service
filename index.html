<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>California Demand — Hex Sampling within State Boundary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body,
    #container {
      margin: 0;
      height: 100%;
      width: 100%;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: rgba(255, 255, 255, .96);
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, .15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #ui .row {
      display: flex;
      align-items: center;
      gap: .5rem;
    }

    #ui label {
      font-size: .9rem;
      color: #333;
    }

    #ui input[type=range] {
      width: 180px;
    }
  </style>

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- deck.gl -->
  <script src="https://unpkg.com/deck.gl@8.9.34/dist.min.js"></script>

  <!-- turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="./rbush.min.js"></script>

</head>

<body>
  <div id="container"></div>
  <div id="ui">
    <div class="row"><strong>California Map Service</strong></div>
    <div class="row" style="margin-top:.25rem">
      <label for="category">Category:</label>
      <select id="category"></select>
    </div>
    <div class="row" style="margin-top:.25rem">
      <label for="coverage_mode">Coverage:</label>
      <select id="coverage_mode">
        <option value="integer">Integer radii</option>
        <option value="exact">Exact min distance</option>
      </select>
    </div>
    <div class="row" style="margin-top:.25rem">
      <input id="allow_zero" type="checkbox" checked />
      <label for="allow_zero">Allow (radius < starting radius) when (ZIP's doctors ≥ 5)</label>
    </div>
    <div class="row" style="font-size:0.9rem;color:#555;margin-bottom:.3rem">
      Approximated by affecting demand in radius of 0.1 miles.
    </div>
    <div class="row" style="margin-top:.25rem">
      <label for="start_radius">Starting radius (mi):</label>
      <input id="start_radius" type="number" min="0" step="1" value="5" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <label for="inc_radius">Radius increment (mi):</label>
      <input id="inc_radius" type="number" min="1" step="1" value="5" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <label>Hex size (pixels): <span id="hex_px_label">24</span></label>
      <input id="hex_px" type="range" min="12" max="60" value="26" step="2" />
    </div>
    <div class="row" style="margin-top:.25rem">
      <label>Opacity (alpha): <span id="hex_opacity_label">125</span></label>
      <input id="hex_opacity" type="range" min="0" max="255" value="125" step="5" />
    </div>
  </div>

  <script>
    // CONFIG
    const DATA_URL = './zips.json';
    const MAP_STYLE = `https://api.maptiler.com/maps/streets/style.json?key=NYtv1R1Zg4AkgQWZVE5K`;
    const ZCTA_URL = './zcta_ca_centroid.geojson';
    const START_VIEW = { latitude: 37.25, longitude: -119.75, zoom: 6, bearing: 0, pitch: 0 };
    const MAX_HEX_DISTANCE = 150; // miles

    const EARTH_RADIUS = 3958.7564; // miles
    //const US_STATES_GEOJSON = 'https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json';
    const CA_BOUNDARY_URL = './ca_boundary.json';
    const SHOW_ZERO_CELLS = false;

    const categoryEl = document.getElementById('category');
    const coverageModeEl = document.getElementById('coverage_mode');

    const allowZeroEl = document.getElementById('allow_zero');
    const startRadiusEl = document.getElementById('start_radius');
    const incRadiusEl = document.getElementById('inc_radius');

    const hexPxSlider = document.getElementById('hex_px');
    const hexPxLabel = document.getElementById('hex_px_label');
    let HEX_PIXEL_SIZE = +hexPxSlider.value;

    const hexOpacitySlider = document.getElementById('hex_opacity');
    const hexOpacityLabel = document.getElementById('hex_opacity_label');
    let HEX_OPACITY = +hexOpacitySlider.value;

    // UTILS
    function metersPerPixel(lat, zoom) {
      const mpp256 = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
      return mpp256 / 2;
    }

    function hexPolygon([lon, lat], Rm) {
      const latRad = lat * Math.PI / 180;
      const mPerDegLat = 111132.92 - 559.82 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
      const mPerDegLon = 111412.84 * Math.cos(latRad) - 93.5 * Math.cos(3 * latRad);
      const dLat = Rm / mPerDegLat, dLon = Rm / mPerDegLon;
      const ang = [30, 90, 150, 210, 270, 330].map(a => a * Math.PI / 180);
      return ang.map(a => [lon + dLon * Math.cos(a), lat + dLat * Math.sin(a)]);
    }

    function makeHexCenters(vs, hexPixelSize = HEX_PIXEL_SIZE) {
      const { longitude, latitude, zoom, width, height } = vs;
      const mpp = metersPerPixel(latitude, zoom);
      const Rm = Math.max(200, (hexPixelSize * mpp) / 2);

      const vp = new deck.WebMercatorViewport(vs);
      const nw = vp.unproject([0, 0]);
      const se = vp.unproject([width, height]);
      const minLon = Math.min(nw[0], se[0]);
      const maxLon = Math.max(nw[0], se[0]);
      const minLat = Math.min(se[1], nw[1]);
      const maxLat = Math.max(se[1], nw[1]);

      const latRad = latitude * Math.PI / 180;
      const mPerDegLat = 111132.92 - 559.82 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
      const mPerDegLon = 111412.84 * Math.cos(latRad) - 93.5 * Math.cos(3 * latRad);
      const stepLon = (2 * Rm) / mPerDegLon;
      const stepLat = (Math.sqrt(3) * Rm) / mPerDegLat;

      const centers = [];
      let row = 0;
      for (let lat = minLat - stepLat; lat <= maxLat + stepLat; lat += stepLat, row++) {
        const lonOffset = (row % 2 === 0) ? 0 : stepLon / 2;
        for (let lon = minLon - stepLon; lon <= maxLon + stepLon; lon += stepLon) {
          centers.push([lon + lonOffset, lat]);
        }
      }
      return { centers, hexRadiusMeters: Rm };
    }

    function haversineMi(lat1, lon1, lat2, lon2) {
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
      return 2 * EARTH_RADIUS * Math.asin(Math.sqrt(a));
    }

    function bandsForMiles(latDeg, miles) {
      if (miles <= 0) return { latBand: 0, lonBand: 0 };
      const latBand = miles / 69.0; // ~1 deg lat ≈ 69 miles
      const lonBand = miles / (69.172 * Math.max(0.01, Math.cos(latDeg * Math.PI / 180)));
      return { latBand, lonBand };
    }


    function withinMilesBB(lat1, lon1, lat2, lon2, miles) {
      const { latBand, lonBand } = bandsForMiles(lat1, miles);
      return (lat2 >= lat1 - latBand && lat2 <= lat1 + latBand &&
        lon2 >= lon1 - lonBand && lon2 <= lon1 + lonBand);
    }

    // ---- CATEGORY + NEIGHBOR HELPERS ----
    const CATS = [];                         // populated at load time, e.g., ["DCH","MOS","MPA",...]
    let ZIP_IDX = new Map();                 // zip -> row index
    let ROWS = [];                           // keep raw rows for neighbor lookup
    let NEIGHBOR_DISTS = [];                 // [i] -> Float64Array distances aligned to nearest_zips
    let CAT_PREFIX = {};                     // CAT_PREFIX[cat][i] -> Float64Array cumulative doctors aligned to nearest_zips
    let ABS_MIN_CACHE = {};                  // ABS_MIN_CACHE[cat][i] -> number (abs min radius in mi)

    // upper bound index of x in sorted numeric array arr (first index with arr[k] > x)
    function upperBound(arr, x) {
      let lo = 0, hi = arr.length;
      while (lo < hi) {
        const mid = (lo + hi) >>> 1;
        if (arr[mid] <= x) lo = mid + 1; else hi = mid;
      }
      return lo;
    }

    function getCategoriesFromRows(sampleRow) {
      // detect keys ending with "_demand" like "DCH_demand"
      const cats = [];
      for (const k of Object.keys(sampleRow)) {
        const m = /^([A-Z]{3})_demand$/i.exec(k);
        if (m) cats.push(m[1].toUpperCase());
      }
      return cats.length ? cats : ["DCH"]; // fallback
    }

    function doctorOf(row, cat) {
      return Number(row[`${cat}_doctors`]) || 0;
    }

    function demandOf(row, cat) {
      return Number(row[`${cat}_demand`]) || 0;
    }

    function ensurePrefix(cat) {
      if (!CAT_PREFIX[cat]) CAT_PREFIX[cat] = [];
    }

    function buildNeighborDistsIfNeeded(i) {
      if (NEIGHBOR_DISTS[i]) return;
      const zi = ROWS[i];
      const baseLat = +zi.latitude, baseLon = +zi.longitude;
      const nbrZips = zi.nearest_zips || [];
      const dists = new Float64Array(nbrZips.length);
      for (let k = 0; k < nbrZips.length; k++) {
        const j = ZIP_IDX.get(nbrZips[k]);
        const zj = ROWS[j];
        dists[k] = haversineMi(baseLat, baseLon, +zj.latitude, +zj.longitude);
      }
      NEIGHBOR_DISTS[i] = dists;
    }

    function buildPrefixForCatIfNeeded(cat, i) {
      ensurePrefix(cat);
      if (CAT_PREFIX[cat][i]) return;
      const row = ROWS[i];
      const nbrZips = row.nearest_zips || [];
      const pref = new Float64Array(nbrZips.length);
      let acc = 0;
      for (let k = 0; k < nbrZips.length; k++) {
        const j = ZIP_IDX.get(nbrZips[k]);
        acc += doctorOf(ROWS[j], cat);
        pref[k] = acc;
      }
      CAT_PREFIX[cat][i] = pref;
    }

    function getAbsMinRadius(cat, i, minDocs = 5) {
      if (!ABS_MIN_CACHE[cat]) ABS_MIN_CACHE[cat] = [];
      if (typeof ABS_MIN_CACHE[cat][i] === 'number') return ABS_MIN_CACHE[cat][i];
      buildNeighborDistsIfNeeded(i);
      buildPrefixForCatIfNeeded(cat, i);

      const dists = NEIGHBOR_DISTS[i];
      const pref  = CAT_PREFIX[cat][i];
      // first index where prefix >= minDocs
      let k = -1;
      for (let t = 0; t < pref.length; t++) { if (pref[t] >= minDocs) { k = t; break; } }
      const val = (k >= 0) ? dists[k] : Infinity;
      ABS_MIN_CACHE[cat][i] = val;
      return val;
    }

    function sumDoctorsWithin(cat, i, radiusMiles) {
      buildNeighborDistsIfNeeded(i);
      buildPrefixForCatIfNeeded(cat, i);
      const dists = NEIGHBOR_DISTS[i];
      const pref  = CAT_PREFIX[cat][i];
      const k = upperBound(dists, radiusMiles) - 1; // last index with dist <= radius
      return (k >= 0) ? pref[k] : 0;
    }


    // GLOBALS
    let POINTS = [];
    let SUM_DOCTORS = null;
    let CA_FEATURE = null;
    let ZCTA_FEATURES = null;
    let ZCTA_INDEX = null;
    let overlay = null;
    let map = null;

    // LOADERS
    async function loadData() {
      try {
        const r = await fetch(DATA_URL, { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        return await r.json();
      } catch (e) {
        throw e;
      }
    }

    function buildZctaIndex() {
      ZCTA_INDEX = rbush(9);
      const items = [];
      const feats = (ZCTA_FEATURES && ZCTA_FEATURES.features) || [];
      for (let i = 0; i < feats.length; i++) {
        const b = turf.bbox(feats[i]); // [minX, minY, maxX, maxY] in [lon, lat]
        items.push({ minX: b[0], minY: b[1], maxX: b[2], maxY: b[3], i });
      }
      ZCTA_INDEX.load(items);
    }

    /** Returns containing ZCTA feature for (lon,lat), or null */
    function findZctaForPoint(lon, lat) {
      if (!ZCTA_INDEX) return null;
      const cands = ZCTA_INDEX.search({ minX: lon, minY: lat, maxX: lon, maxY: lat });
      for (const it of cands) {
        const f = ZCTA_FEATURES.features[it.i];
        if (turf.booleanPointInPolygon([lon, lat], f)) return f;
      }
      return null;
    }

    async function ensureRbush() {
      // If already present (e.g., from local rbush.min.js), done.
      if (window.rbush) return;

      // Try dynamic ESM imports that return the class as .default
      const candidates = [
        'https://cdn.jsdelivr.net/npm/rbush@3.0.1/+esm',
        'https://unpkg.com/rbush@3.0.1/+esm'
      ];

      for (const url of candidates) {
        try {
          const mod = await import(url);
          // expose a global-compatible factory so the rest of your code can call rbush(...)
          window.rbush = function rbushFactory(maxEntries) {
            // rbush ESM default export is the class; `new` creates the tree
            return new mod.default(maxEntries);
          };
          return;
        } catch (e) {
          console.warn('Failed to import rbush from', url, e);
        }
      }

      // Last resort: try loading a local fallback if you saved rbush.min.js next to index.html
      try {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = './rbush.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
        if (window.rbush) return;
      } catch (e) {
        console.warn('Local rbush.min.js failed to load', e);
      }

      throw new Error('rbush could not be loaded from any source');
    }

    async function loadBoundary() {
      // Try local high-res file first
      try {
        const r = await fetch(CA_BOUNDARY_URL, { cache: 'no-cache' });
        if (r.ok) {
          const gj = await r.json();

          // --- Normalize to a single Feature (Polygon/MultiPolygon)
          let feat;
          if (gj.type === 'Feature') {
            feat = gj;
          } else if (gj.type === 'FeatureCollection') {
            // If your json has multiple features, pick the one that is CA or a Polygon
            feat = gj.features.find(f =>
              f?.geometry?.type === 'Polygon' || f?.geometry?.type === 'MultiPolygon'
            ) || gj.features[0];
          } else if (gj.type === 'Polygon' || gj.type === 'MultiPolygon') {
            feat = { type: 'Feature', properties: { name: 'California' }, geometry: gj };
          }

          if (!feat || !feat.geometry || !feat.geometry.coordinates) {
            console.error('CA boundary file did not contain a Polygon/MultiPolygon Feature:', gj);
            throw new Error('Invalid CA boundary GeoJSON');
          }

          console.log('CA boundary loaded. type:', feat.geometry.type);
          return feat;
        }
      } catch (e) {
        console.warn('CA polygon fetch failed, falling back to inline rectangle.', e);
      }

      // Fallback: inline rectangle you already had
      const fc = JSON.parse(document.getElementById('cali-boundary').textContent.trim());
      return fc.features[0];
    }

    // RENDER
    function renderAdjustedDemand(viewState) {
      if (!CA_FEATURE) return;

      // Build hex centers
      const { centers, hexRadiusMeters } = makeHexCenters(viewState);
      const features = [];

      // UI selections
      const allowZero    = !!allowZeroEl?.checked;
      const startMiles   = Math.max(0, parseInt(startRadiusEl?.value || '1', 10));
      const incMiles     = Math.max(1, parseInt(incRadiusEl?.value || '1', 10));
      const coverageMode = coverageModeEl?.value || 'integer';
      const selCat       = (categoryEl?.value || CATS[0] || 'DCH').toUpperCase();

      // Pre-extract for tight loops
      const ZN = POINTS.length;
      const zLat = new Float64Array(ZN);
      const zLon = new Float64Array(ZN);
      const zDem = new Float64Array(ZN); // demand for selected category

      for (let i = 0; i < ZN; i++) {
        const p = POINTS[i];
        zLat[i] = +p.lat;
        zLon[i] = +p.lon;
        const row = ROWS[i];
        zDem[i] = demandOf(row, selCat);       // e.g., DCH_demand
      }

      // in case there are errors with perfect fits for circles
      const EPS = 0.1;
      const debugTables = [];

      centers.forEach(([hxLon, hxLat]) => {
        if (!turf.booleanPointInPolygon([hxLon, hxLat], CA_FEATURE)) return;
        
        const debugRows = [];

        // Bounding box for 150 mi around this hex center (cheap prefilter)
        const { latBand: hexLatBand, lonBand: hexLonBand } = bandsForMiles(hxLat, MAX_HEX_DISTANCE);

        let adjusted = 0;

        // Loop candidate ZIPs within 150 miles of hex center
        for (let i = 0; i < ZN; i++) {
          const lat = zLat[i], lon = zLon[i];

          // BB prune
          if (!(lat >= hxLat - hexLatBand && lat <= hxLat + hexLatBand &&
            lon >= hxLon - hexLonBand && lon <= hxLon + hexLonBand)) continue;

          // Exact 150-mi check
          if (haversineMi(hxLat, hxLon, lat, lon) > MAX_HEX_DISTANCE) continue;

          // Decide working radius for this ZIP based on the selected category
          const catAbsMin = Number(ROWS[i]?.[`${selCat}_abs_min_radius`]);
          let rMiles;
          if (coverageMode === 'exact') {
            // exact fractional miles (allowZero -> 0 stays 0)
            rMiles = (allowZero && catAbsMin === 0) ? 0 : catAbsMin;
          } else {
            // integer stepping: start at UI startMiles and step until >= per-cat abs min
            if (allowZero && catAbsMin === 0) {
              rMiles = 0;
            } else {
              rMiles = startMiles;
              while (Number.isFinite(catAbsMin) && rMiles < catAbsMin) rMiles += incMiles;
            }
          }
          
          // DEBUG TESTING PURPOSES, REMOVE AFTER
          // if (coverageMode !== 'exact' && rMiles > 50) {
          //   console.log(
          //     `⚠️ ZIP ${ROWS[i].zip} has suspiciously large radius (${rMiles.toFixed(2)} mi),`,
          //     `abs_min=${catAbsMin?.toFixed?.(2) || catAbsMin}, startMiles=${startMiles}, inc=${incMiles}`
          //   );
          // }

          // Distance gating (unchanged)
          if (rMiles > 0) {
            if (!withinMilesBB(hxLat, hxLon, lat, lon, rMiles) ||
                haversineMi(hxLat, hxLon, lat, lon) > rMiles + EPS) continue;
          } else {
            // r == 0 → same ZCTA requirement (unchanged)
            const zcta = findZctaForPoint(hxLon, hxLat);
            if (!zcta) continue;
            if (!turf.booleanPointInPolygon([lon, lat], zcta)) continue;
          }

          // Denominator: doctors within rMiles for THIS category and THIS source zip i
          const sumDocs = (rMiles === 0)
            ? doctorOf(ROWS[i], selCat)         // only self at 0 radius
            : sumDoctorsWithin(selCat, i, rMiles); // cumulative via nearest_zips / prefix
          

          // DEBUG!!!
          if (debugRows) {
            const distMi = haversineMi(hxLat, hxLon, lat, lon);

            // per-category denominator you already compute
            // const sumDocs = (rMiles === 0)
            //   ? doctorOf(ROWS[i], selCat)
            //   : sumDoctorsWithin(selCat, i, rMiles);

            debugRows.push({
              zip: ROWS[i].zip,
              cat: selCat,
              rMiles: Number(rMiles.toFixed(2)),
              abs_min: Number((ROWS[i][`${selCat}_abs_min_radius`] ?? 0).toFixed?.(2) || 0),
              distMi: Number(distMi.toFixed(2)),
              demand: Number(demandOf(ROWS[i], selCat).toFixed(2)),
              docsWithinR: Number((sumDocs ?? 0).toFixed(2))
            });
          }

          if (sumDocs > 0) adjusted += (zDem[i] / sumDocs);
          
          if (debugRows) {
            // Sort contributors by distance for readability
            //debugRows.sort((a, b) => a.distMi - b.distMi);
            debugTables.push({
              hex: `${hxLat.toFixed(5)}, ${hxLon.toFixed(5)}`,
              rows: debugRows
            });
          }
        }

        features.push({ center: [hxLon, hxLat], adjusted });
      });

      const used = (features.filter(f => f.adjusted > 0));

      // If nothing to draw, keep border only
      if (used.length === 0) {
        overlay.setProps({
          layers: [new deck.GeoJsonLayer({
            id: 'cali-border',
            data: CA_FEATURE,
            stroked: true,
            filled: false,
            getLineColor: [0, 0, 0, 200],
            lineWidthMinPixels: 2
          })],
          getTooltip: null
        });
        return;
      }

      // Color scaling by adjusted demand
      const maxVal = Math.max(1, ...used.map(f => f.adjusted));
      const colorFor = v => {
        const t = Math.min(1, v / maxVal);
        return [255, Math.floor(255 * (1 - t)), Math.floor(60 + 60 * (1 - t)), HEX_OPACITY];
      };

      const polygons = used.map(f => ({
        polygon: hexPolygon(f.center, hexRadiusMeters),
        adjusted: f.adjusted,
        color: colorFor(f.adjusted)
      }));

      const hexLayer = new deck.PolygonLayer({
        id: 'adjusted-hexes',
        data: polygons,
        getPolygon: d => d.polygon,
        getFillColor: d => d.color,
        stroked: false,
        filled: true,
        pickable: true
      });

      const borderLayer = new deck.GeoJsonLayer({
        id: 'cali-border',
        data: CA_FEATURE,
        stroked: true,
        filled: false,
        getLineColor: [0, 0, 0, 200],
        lineWidthMinPixels: 2
      });

      const zctaOutlineLayer = new deck.GeoJsonLayer({
        id: 'zcta-outline',
        data: ZCTA_FEATURES || { type: 'FeatureCollection', features: [] },
        stroked: true,
        filled: false,
        getLineColor: [85, 85, 85, 180],
        lineWidthMinPixels: 1
      });

      if (debugTables.length) {
        for (const t of debugTables) {
          console.log(`Contributors for HEX(${t.hex}) — ${t.rows.length} zips`);
          console.table(t.rows);
        }
      }

      overlay.setProps({
        layers: [borderLayer, zctaOutlineLayer, hexLayer],
        getTooltip: ({ object }) =>
          object ? `Panel demand per yearly quarter per doctor: ${object.adjusted.toFixed(4)}` : null
      });
    }

    // STARTUP
    Promise.all([
      ensureRbush(),
      loadData(),
      loadBoundary(),
      fetch(ZCTA_URL).then(r => r.json()),
      //fetch(DOCS_BY_ZIP_URL).then(r => r.ok ? r.json() : ({})) // ok if missing
    ]).then(([_, rows, ca, zcta]) => {
      ROWS = rows; // keep raw rows

      // Detect categories like DCH/MOS/... from *_demand keys
      CATS.splice(0, CATS.length, ...getCategoriesFromRows(rows[0] || {}));

      // Populate the category dropdown
      categoryEl.innerHTML = '';
      for (const c of CATS) {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        categoryEl.appendChild(opt);
      }

      // Build POINTS + ZIP index (for fast lookups)
      POINTS = rows.map((d, idx) => {
        const zip = ('' + (d.zip ?? d.ZIP ?? '')).padStart(5,'0');
        ZIP_IDX.set(zip, idx);
        return { lon: +d.longitude, lat: +d.latitude, zip };
      }).filter(p => Number.isFinite(p.lon) && Number.isFinite(p.lat));
      console.log('Loaded ZIP points:', POINTS.length);

      CA_FEATURE = ca;
      console.log('Loaded CA feature from source:', CA_FEATURE.properties?.name || CA_FEATURE.properties?.NAME);

      ZCTA_FEATURES = zcta;
      buildZctaIndex(); // <-- build spatial index once

      map = new maplibregl.Map({
        container: 'container',
        style: MAP_STYLE,
        center: [START_VIEW.longitude, START_VIEW.latitude],
        zoom: START_VIEW.zoom
      });

      overlay = new deck.MapboxOverlay({ interleaved: true, layers: [] });
      map.addControl(overlay);

      map.on('move', () => {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      });

      // First render
      renderAdjustedDemand({
        longitude: map.getCenter().lng,
        latitude: map.getCenter().lat,
        zoom: map.getZoom(),
        pitch: map.getPitch(),
        bearing: map.getBearing(),
        width: map.getContainer().clientWidth,
        height: map.getContainer().clientHeight
      });
    });


    // SLIDERS
    hexPxSlider.addEventListener('input', () => {
      HEX_PIXEL_SIZE = +hexPxSlider.value;
      hexPxLabel.textContent = HEX_PIXEL_SIZE;
      if (map) {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      }
    });

    hexOpacitySlider.addEventListener('input', () => {
      HEX_OPACITY = +hexOpacitySlider.value;
      hexOpacityLabel.textContent = HEX_OPACITY;
      if (map) {
        const vs = {
          longitude: map.getCenter().lng,
          latitude: map.getCenter().lat,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.getContainer().clientWidth,
          height: map.getContainer().clientHeight
        };
        renderAdjustedDemand(vs);
      }
    });

    function rerenderNow() {
      if (!map) return;
      const vs = {
        longitude: map.getCenter().lng,
        latitude: map.getCenter().lat,
        zoom: map.getZoom(),
        pitch: map.getPitch(),
        bearing: map.getBearing(),
        width: map.getContainer().clientWidth,
        height: map.getContainer().clientHeight
      };
      renderAdjustedDemand(vs);
    }

    categoryEl.addEventListener('change', rerenderNow);
    coverageModeEl.addEventListener('change', rerenderNow);
    allowZeroEl.addEventListener('change', rerenderNow);
    startRadiusEl.addEventListener('input', rerenderNow);
    incRadiusEl.addEventListener('input', rerenderNow);
  </script>
</body>

</html>